# Invariants for etcd/Raft Systems
# Includes both generic Raft consensus properties and etcd-specific features

invariants:
  # Generic Raft Consensus Invariants (applicable to all Raft implementations)
  - name: "LeaderUniqueness"
    type: "safety"
    natural_language: "At most one leader can exist in any given term across all nodes in the cluster"
    formal_description: "For any given term T, there can be at most one node in the cluster that considers itself the leader for that term. This is fundamental to the safety of Raft."
    tla_example: |
      LeaderUniqueness == 
        \A term \in Terms :
          Cardinality({n \in Nodes : 
            /\ serverState[n] = Leader
            /\ currentTerm[n] = term}) <= 1
    
  - name: "LogConsistency" 
    type: "safety"
    natural_language: "If two logs contain an entry with the same index and term, then the logs are identical up to that index"
    formal_description: "The Raft log consistency property: if two different nodes have log entries with the same index and term, then their logs are identical in all preceding entries."
    tla_example: |
      LogConsistency ==
        \A n1, n2 \in Nodes :
          \A idx \in Nat :
            /\ idx \in DOMAIN log[n1] 
            /\ idx \in DOMAIN log[n2]
            /\ log[n1][idx].term = log[n2][idx].term
            => \A j \in 1..idx : log[n1][j] = log[n2][j]

  - name: "LeaderCompletenessProperty"
    type: "safety"
    natural_language: "If a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms"
    formal_description: "Once an entry is committed, it must appear in all future leader logs. This ensures that committed entries are never lost or overwritten."
    tla_example: |
      LeaderCompletenessProperty ==
        \A commitTerm \in Terms, commitIdx \in Nat :
          \A leaderTerm \in Terms, leader \in Nodes :
            /\ leaderTerm > commitTerm
            /\ serverState[leader] = Leader  
            /\ currentTerm[leader] = leaderTerm
            /\ IsCommitted(commitIdx, commitTerm)
            => /\ commitIdx \in DOMAIN log[leader]
               /\ log[leader][commitIdx].term = commitTerm

  - name: "StateMachineSafety"
    type: "safety"
    natural_language: "All nodes apply the same sequence of committed log entries to their state machines"
    formal_description: "State machine safety ensures that all nodes that have applied log entries up to the same index have applied exactly the same sequence of entries."
    tla_example: |
      StateMachineSafety ==
        \A n1, n2 \in Nodes :
          \A idx \in Nat :
            /\ idx <= commitIndex[n1]
            /\ idx <= commitIndex[n2]  
            /\ idx > 0
            => log[n1][idx] = log[n2][idx]

  - name: "VoteUniqueness"
    type: "safety"
    natural_language: "Each node can vote for at most one candidate in any given term"
    formal_description: "A node can cast at most one vote per term, preventing split-vote scenarios that could lead to election failures."
    tla_example: |
      VoteUniqueness ==
        \A n \in Nodes, term \in Terms :
          (votedFor[n] /= None /\ currentTerm[n] = term) =>
            \A candidate \in Nodes :
              (votedFor[n] = candidate) => 
                ~(\E otherCandidate \in Nodes : 
                  otherCandidate /= candidate /\ VotedFor(n, otherCandidate, term))

  # etcd-specific Invariants (aligned with prompt modeling requirements)
  - name: "PreVotePhaseConsistency"
    type: "safety"
    natural_language: "Pre-vote phase correctly prevents unnecessary term increments"
    formal_description: "etcd-specific: PreVote mechanism ensures terms only increment when a candidate can actually get majority support (required by prompt)"
    tla_example: |
      PreVotePhaseConsistency ==
        \A n \in Nodes :
          (serverState[n] = StatePreCandidate) =>
            CanReceiveMajorityPreVotes(n, currentTerm[n])

  - name: "MessageTypeHandling"
    type: "safety"
    natural_language: "Different message types are handled correctly based on node state"
    formal_description: "etcd message processing: MsgHup, MsgVote/MsgVoteResp, MsgApp/MsgAppResp messages are processed according to current node state"
    tla_example: |
      MessageTypeHandling ==
        \A n \in Nodes, msg \in Messages :
          ProcessMessage(n, msg) =>
            /\ (msg.type = MsgHup) => (serverState[n] \in {StateFollower, StatePreCandidate})
            /\ (msg.type = MsgVote) => ValidVoteMessage(msg)
            /\ (msg.type = MsgApp) => ValidAppendMessage(msg)

  - name: "ClientProposalHandling"
    type: "safety"
    natural_language: "Client proposals (MsgProp) are only processed by leaders and create valid log entries"
    formal_description: "etcd client proposals: MsgProp messages are only accepted by leaders and result in properly formatted log entries"
    tla_example: |
      ClientProposalHandling ==
        \A n \in Nodes, proposal \in ClientProposals :
          AcceptProposal(n, proposal) =>
            /\ serverState[n] = StateLeader
            /\ ValidLogEntry(proposal.entry)
            /\ proposal.entry.term = currentTerm[n]

  - name: "StateTransitionCorrectness"
    type: "safety"
    natural_language: "Node state transitions follow the correct Raft state machine: Follower → PreCandidate → Candidate → Leader"
    formal_description: "etcd state transitions: strict state machine transitions with prevote phase"
    tla_example: |
      StateTransitionCorrectness ==
        \A n \in Nodes :
          /\ (serverState'[n] = StatePreCandidate) => (serverState[n] = StateFollower)
          /\ (serverState'[n] = StateCandidate) => (serverState[n] = StatePreCandidate)
          /\ (serverState'[n] = StateLeader) => (serverState[n] = StateCandidate)

  - name: "TermAdvancementCorrectness"
    type: "safety"
    natural_language: "Nodes advance their term only when receiving messages with higher terms"
    formal_description: "etcd term advancement: nodes update currentTerm when receiving higher term messages, ensuring term progression"
    tla_example: |
      TermAdvancementCorrectness ==
        \A n \in Nodes, msg \in Messages :
          (currentTerm'[n] > currentTerm[n]) =>
            /\ ProcessMessage(n, msg)
            /\ msg.term > currentTerm[n]
            /\ currentTerm'[n] = msg.term

  - name: "HeartbeatPreventsElection"
    type: "safety"
    natural_language: "Valid heartbeats from current leader prevent followers from starting elections"
    formal_description: "etcd heartbeat mechanism: followers receiving valid heartbeats reset election timeout and don't become candidates"
    tla_example: |
      HeartbeatPreventsElection ==
        \A n \in Nodes :
          /\ serverState[n] = StateFollower
          /\ ReceiveValidHeartbeat(n)
          => ~(serverState'[n] = StatePreCandidate)

  # Generic Liveness Properties
  - name: "EventualLeaderElection"
    type: "liveness"
    natural_language: "Eventually, a leader will be elected if the majority of nodes are functioning"
    formal_description: "Under fair scheduling and with a majority of nodes operational, the system will eventually elect a leader and make progress."
    tla_example: |
      EventualLeaderElection ==
        /\ MajorityNodesUp
        => <>(E n \in Nodes : serverState[n] = Leader)

  - name: "EventualLogCommitment"
    type: "liveness"
    natural_language: "Proposed log entries will eventually be committed when a stable leader exists"
    formal_description: "Under fair scheduling and stable leadership, proposed entries will eventually be replicated to majority and committed."
    tla_example: |
      EventualLogCommitment ==
        \A entry \in LogEntries :
          (Proposed(entry) /\ StableLeaderExists) ~> Committed(entry)

metadata:
  total_invariants: 12
  safety_invariants: 10
  liveness_invariants: 2
  generic_raft_invariants: 6  # LeaderUniqueness, LogConsistency, LeaderCompletenessProperty, StateMachineSafety, VoteUniqueness, EventualLeaderElection
  etcd_specific_invariants: 6  # PreVotePhaseConsistency, MessageTypeHandling, ClientProposalHandling, StateTransitionCorrectness, TermAdvancementCorrectness, HeartbeatPreventsElection