# Invariants for Asterinas Spinlock Systems
# Includes both generic spinlock properties and Asterinas-specific features

invariants:
  # Generic Spinlock Invariants (applicable to all spinlock implementations)
  - name: "MutualExclusion"
    type: "safety"
    natural_language: "At most one process can be in the critical section at any given time"
    formal_description: "The fundamental safety property: no two processes can be in their critical section simultaneously"
    tla_example: |
      MutualExclusion ==
        Cardinality({p \in Proc : pc[p] = "in_cs"}) <= 1

  - name: "LockConsistency"
    type: "safety"
    natural_language: "The lock state is consistent with critical section occupancy"
    formal_description: "Lock state consistency: the atomic boolean lock state must be consistent with whether any process is in the critical section"
    tla_example: |
      LockConsistency ==
        (lock_state = TRUE) <=> (\E p \in Proc : pc[p] = "in_cs")

  - name: "NoDeadlock"
    type: "safety"
    natural_language: "No process can be stuck spinning forever when the lock is free"
    formal_description: "Deadlock freedom: if a process is spinning, the lock must be currently held by someone"
    tla_example: |
      NoDeadlock ==
        \A p \in Proc : (pc[p] = "spinning") => (lock_state = TRUE)

  - name: "TryLockNoSpinning"
    type: "safety"
    natural_language: "try_lock() operations never enter the spinning state - they succeed or fail immediately"
    formal_description: "Asterinas-specific: try_lock() is non-blocking and should never cause a process to spin"
    tla_example: |
      TryLockNoSpinning ==
        \A p \in Proc : 
          pc[p] = "req_try_lock" => thread_state[p] \notin {"trying", "spinning"}

  - name: "BlockingVsNonBlockingSemantics"
    type: "safety"
    natural_language: "Only lock() requests can lead to spinning, try_lock() requests cannot"
    formal_description: "Asterinas dual-interface semantics: spinning state can only be reached via lock(), not try_lock()"
    tla_example: |
      BlockingVsNonBlockingSemantics ==
        \A p \in Proc :
          pc[p] = "spinning" => 
            \E q \in Proc : q = p /\ (pc[q] \in {"req_lock", "spinning"})

  - name: "GuardLifecycle"
    type: "safety"
    natural_language: "Process in critical section will eventually return to idle state"
    formal_description: "RAII Guard semantics: every lock acquisition must be paired with exactly one release"
    tla_example: |
      GuardLifecycle ==
        \A p \in Proc :
          pc[p] = "in_cs" => <>(pc[p] = "idle")

  # Generic Liveness Property
  - name: "EventualRelease"
    type: "liveness"
    natural_language: "A process using blocking lock() will eventually release the lock under fair scheduling"
    formal_description: "Under fair scheduling, any process that has acquired a lock will eventually release it"
    tla_example: |
      EventualRelease == \A t \in Threads : (thread_state[t] = "locked") ~> (thread_state[t] = "idle")

metadata:
  total_invariants: 7
  safety_invariants: 6
  liveness_invariants: 1
  generic_invariants: 4  # MutualExclusion, LockConsistency, NoDeadlock, EventualRelease
  asterinas_specific_invariants: 3  # TryLockNoSpinning, BlockingVsNonBlockingSemantics, GuardLifecycle