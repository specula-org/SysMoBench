# Simplified Invariants for Spinlock Systems

invariants:
  - name: "MutualExclusion"
    type: "safety"
    natural_language: "At most one thread can hold the lock at any given time"
    formal_description: "The fundamental safety property: no two threads can be in their critical section simultaneously"
    tla_example: |
      MutualExclusion ==
        Cardinality({t \in Threads : threadState[t] = InCriticalSection}) <= 1

  - name: "LockConsistency"
    type: "safety"
    natural_language: "The lock state is consistent with thread ownership - if lock is held, exactly one thread owns it"
    formal_description: "Lock state consistency: the atomic boolean lock state must be consistent with which thread (if any) currently owns the lock"
    tla_example: |
      LockConsistency ==
        /\ (lockState = TRUE) => (\E t \in Threads : owner[t] = TRUE)
        /\ (lockState = FALSE) => (\A t \in Threads : owner[t] = FALSE)
        /\ Cardinality({t \in Threads : owner[t] = TRUE}) <= 1

  - name: "DeadlockFreedom"
    type: "safety"
    natural_language: "No deadlock can occur - the system can always make progress"
    formal_description: "Deadlock freedom for spinlocks: if threads are waiting for the lock, eventually the lock holder will release it"
    tla_example: |
      DeadlockFreedom ==
        \A t \in Threads :
          (threadState[t] = Waiting) => (lockState = TRUE)

  - name: "AtomicityProperty"
    type: "safety"
    natural_language: "Lock acquisition and release operations are atomic - no intermediate states are visible"
    formal_description: "The compare-and-swap or test-and-set operations used for lock acquisition must be atomic, with no observable intermediate states"
    tla_example: |
      AtomicityProperty ==
        \A t \in Threads :
          /\ (pc[t] = "acquiring") => (lockState \in {TRUE, FALSE})
          /\ (pc[t] = "releasing") => (owner[t] = TRUE)

  - name: "EventualAcquisition"
    type: "liveness"
    natural_language: "A thread attempting to acquire the lock will eventually succeed under fair scheduling"
    formal_description: "Under fair scheduling assumptions, any thread that attempts to acquire the lock will eventually succeed"
    tla_example: |
      EventualAcquisition ==
        \A t \in Threads :
          (threadState[t] = Waiting) ~> (threadState[t] = InCriticalSection)

metadata:
  total_invariants: 5
  safety_invariants: 4
  liveness_invariants: 1