**What a trace is**

* A trace is a *sequence of JSON objects* (“entries”). Each entry is produced by a `log(...)` call and records a timestamp plus zero or more updates to TLA+ variables.

**Entry schema (one JSON object)**

* Required:

  * `"clock"`: integer timestamp ≥ 0. This is the time *of the log call*; it orders entries.
* Optional:

  * `"event"`: string naming the implementation step/action the entry corresponds to.
  * `"event_args"`: array of strings with event parameters.
* Variable updates:

  * For *each* TLA+ state variable updated since the previous `log`, the entry contains a property whose key is the variable’s name. Its value is an **array of update objects** (must be non‑empty if the variable key is present). In the JSON schema this is modeled via `additionalProperties` (standing for “names of variables”), with `minItems: 1`.

**Update object (elements inside each variable’s array)**

* Required fields (all strings/arrays as below):

  * `"op"`: name of the operation applied.
  * `"path"`: array denoting the field path inside the variable to which the operation applies; **empty array means “the whole variable.”** Paths are lists of field names/keys (e.g., `["address","city"]` or `["rm-0"]`).
  * `"args"`: array of arguments to the operation (may be empty). Contents are JSON values (e.g., strings, numbers, objects).

**Operation names you will see**

* The library emits common ops including `"Update"`, `"Add"`, `"Remove"`, `"Clear"`.

  * `Update`: set the (possibly nested) field at `path` to the value given in `args[0]`.
  * `Add` / `Remove`: add/remove a value to/from a set or bag held in the variable (value is typically in `args[0]`).
  * `Clear`: clear the collection (no args).
    These ops are registered by the tracer via `notifyChange(var, path, operator, args)` or the `VirtualField.apply(op, ...)` and shortcut methods `update(...)`, `add(...)`, `remove(...)`, `clear(...)`.

**Clock and ordering**

* Each component obtains a tracer (`getTracer(tracePath, clock)` or `getTracer(tracePath)`) that logs into a file. The tracer timestamps each `log(...)`. Provided all tracers use the same clock type, entries are recorded **in chronological order both locally and globally**. Supported clock types include in‑memory, file‑based, and server‑based clocks; if a distributed (e.g., Lamport or vector) clock is *managed by the program*, the `log(eventName, args, clockValue)` form is used to set `"clock"` explicitly.

**How entries are formed**

* Calls to `notifyChange(...)` *buffer* variable updates; the next `log(...)` **flushes** all buffered updates into one entry, optionally adding `"event"`/`"event_args"`. If an entry has no variable updates, it may still contain only `"clock"` and `"event"`/`"event_args"`.

**Machine‑readable constraints**

* JSON Schema (Fig. 8) captures:

  * `"clock"`: integer with `minimum: 0` (required).
  * `additionalProperties`: array of **update objects** with **required** keys `"op"`, `"path"`, `"args"` and `minItems: 1`.
  * `"event"`: string (optional).
  * `"event_args"`: array of strings (optional).

**Parsing/replay checklist for another model**

1. Read the trace as a sequence of JSON objects. Sort/process by ascending `"clock"`.
2. For each entry, for each variable key present, iterate its array of update objects in order and apply the operation (`op`, `path`, `args`) to the current abstract state. An empty `path` targets the whole variable.
3. Treat `"event"`/`"event_args"` as optional labels; they do not affect state unless your analysis uses them.

